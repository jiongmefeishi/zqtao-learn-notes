https://www.jianshu.com/p/9db9dd0058f9
https://www.jianshu.com/p/adeb06f9a4f2

https://leetcode-cn.com/circle/article/bwgScY 
https://www.jianshu.com/p/54bfbf147dbd



Java多线程实现的几种方式，Runnable接口有哪些优势？
Java中堆栈的区别。堆栈的增长方向有哪些不同？
输入一个url，发生了什么？从DNS域名服务器工作原理，TCP三次握手
ping的原理是什么？
http1.0和http1.1之间有什么区别
http的请求头里都包含了些什么？，HTTP如何发起请求？
HashMap的实现原理
进程的五种状态以及如何进行切换的？电梯调度算法


微信抢红包如何实现
按层遍历二叉树
java 线程池
线程池的底层原理，以及给出具体场景来设计，你怎么设计。
线程池参数对系统的io cpu 影响
一个动态规划实现设计模式
1用过单例模式吗？知道什么是懒汉式和饿汉式吗？写一个懒汉式看看
2被问懒汉与饿汉式的区别，什么是懒汉式
数据库给你一个表，表的属性有名字、年龄、性别，写一个SQL语句，分别显示年龄大于等于20的男女的数量。
1. zk、b树/b+树、mysql、一道算法；
2. mysql、一致性hash、mq、cap、一道算法；
红黑树
作者：_1031_
链接：https://www.nowcoder.com/discuss/173607
来源：牛客网

红黑树 用的哪一版本的c  c  11用过吗？c  11新特性了解哪些，智能指针用过吗？ java的hashmap底层是怎么实现的？ 堆排序，详细问了怎么建堆，然后引申出了海量数据中找前k个数？ KMP算法 hadoop,spark,hbase一些大数据的东西 一面好像只问了这么多，面试过程中还让我手写了两道算法题 一道是判断链表是否有环
在自我介绍后，就让我写了两道题
第一题是求数组中两数之和等于target的下标对，相同的两数不能重复输出
第二题就是冒泡排序





17、Java中四种引用的关系（强引用、弱引用、软引用、虚引用）
https://blog.csdn.net/linzhiqiang0316/article/details/88591907
	Java中提供这四种引用类型主要有两个目的：

	第一是可以让程序员通过代码的方式决定某些对象的生命周期；
	第二是有利于JVM进行垃圾回收。

	具体介绍：

	一、强引用
		 强引用有引用变量指向时永远不会被垃圾回收，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。

		 强引用就是 new 对象

		 如果想中断强引用和某个对象之间的关联，可以显示地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象。
	二、软引用
		如果一个对象具有软引用，只要内存空间足够，垃圾回收器就不会回收它；

		如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。

		软引用可用来实现内存敏感的高速缓存,比如网页缓存、图片缓存等。使用软引用能防止内存泄露，增强程序的健壮性。
		
		举个栗子：

			MyObject aRef = new  MyObject();  
			SoftReference aSoftRef=new SoftReference(aRef); 


	三、弱引用
		1、弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象
		
		具体事例
			public class test {  
			    public static void main(String[] args) {  
				WeakReference<People>reference=new WeakReference<People>(new People("zhouqian",20));  
				System.out.println(reference.get());  
				System.gc();//通知GVM回收资源  
				System.out.println(reference.get());  
			    }  
			}  
			class People{  
			    public String name;  
			    public int age;  
			    public People(String name,int age) {  
				this.name=name;  
				this.age=age;  
			    }  
			    @Override  
			    public String toString() {  
				return "[name:"+name+",age:"+age+"]";  
			    }  
			} 
		
		输出结果：
		[name:zhouqian,age:20]
		null

		2、不过要注意的是，这里所说的被弱引用关联的对象是指只有弱引用与之关联，如果存在强引用同时与之关联，
		则进行垃圾回收时也不会回收该对象（软引用也是如此）。

		例如：使用强引用对象和弱引用进行关联

		    public static void main(String[] args) {  
			People people=new People("zhouqian",20);  
			WeakReference<People>reference=new WeakReference<People>(people);//<span style="color:#FF0000;">关联强引用</span>  
			System.out.println(reference.get());  
			System.gc();  
			System.out.println(reference.get());  
		    } 

		输出结果：
					
			[name:zhouqian,age:20]  
			[name:zhouqian,age:20]  

			并没有被GC回收
		
		3、弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被JVM回收，这个弱引用就会被加入到与之关联的引用队列中。

	四、虚引用
		虚引用必须和引用队列关联使用，虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期，
		如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。

	五、实际应用

		1）、如何利用软引用和弱引用解决OOM问题？

		　　下面举个例子，假如有一个应用需要读取大量的本地图片，如果每次读取图片都从硬盘读取，则会严重影响性能，
		    但是如果全部加载到内存当中，又有可能造成内存溢出，此时使用软引用可以解决这个问题。

		　　设计思路是：
			用一个HashMap来保存图片的路径 和 相应图片对象关联的软引用之间的映射关系，在内存不足时，
			JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题。
			在Android开发中对于大量图片下载会经常用到。
		2）、使用软引用构建敏感数据的缓存

			a.1）为什么需要使用软引用？

			首先，我们看一个雇员信息查询系统的实例。

			我们将使用一个Java语言实现的雇员信息查询系统查询：存储在磁盘文件或者数据库中的雇员人事档案信息。

			作为一个用户，我们完全有可能需要回头去查看几分钟甚至几秒钟前查看过的雇员档案信息
			(同样，我们在浏览WEB页面的时候也经常会使用“后退”按钮)。
			
			这时我们通常会有两种程序实现方式:

				一种是把过去查看过的雇员信息保存在内存中，每一个存储了雇员档案信息的Java对象的生命周期贯穿整个应用程序始终;

				另一种是当用户开始查看其他雇员的档案信息的时候，把存储了当前所查看的雇员档案信息的Java对象结束引用，使得GC可以回收其所占用的内存空间，
				当用户再次需要浏览该雇员的档案信息的时候，重新构建该雇员的信息。
				
			很显然，第一种实现方法将造成大量的内存浪费，
			而第二种实现的缺陷在于即使垃圾收集线程还没有进行垃圾收集，包含雇员档案信息的对象仍然完好地保存在内存中，但是应用程序依然要重新构建一个新对象。
			
			我们知道，访问磁盘文件、访问网络资源、查询数据库等操作都是影响应用程序执行性能的重要因素，

			如果能重新获取那些尚未被回收的Java对象的引用，必将减少不必要的访问，大大提高程序的运行速度。

			a.2）如果使用软引用

				SoftReference的特点是它的一个实例保存对一个Java对象的软引用，该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。
				也就是说，一旦SoftReference保存了对一个Java对象的软引用后，在垃圾线程对这个Java对象回收前，
				SoftReference类所提供的get()方法返回Java对象的强引用。另外，一旦垃圾线程回收该Java对象之后，get()方法将返回null。
			
			a.3）使用ReferenceQueue清除失去了软引用对象的SoftReference
				ReferenceQueue是适当的清除机制，避免大量SoftReference对象带来的内存泄漏。
				
				ReferenceQueue queue = new  ReferenceQueue();
				SoftReference  ref=new  SoftReference(aMyObject, queue);






16、Java 中接口和抽象类的区别。
	1、语法层面上的区别

		1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 的抽象方法；

		2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；

		3）抽象类可以有静态代码块和静态方法, 而接口中不能含有静态代码块以及静态方法

		4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。

	2、设计层面上的区别
		 1）抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，
		 包括属性、行为，但是接口却是对类局部（行为）进行抽象。

		 2）设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计；
		 对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；
		 而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。





15、http502与504
	502 bad gateway 顾名思义 网关错误 后端服务器tomcat没有起来，应用服务的问题（前提是接入层7层正常的情况下）。

	应用服务问题一种是应用本身问题；另一种是因为依赖服务问题比如依赖服务RT高，依赖的服务有大的读取（mysql慢查，http等），
	以至于调用方超过超时read时间；服务集群压力大时，也会出现502超时（502理解为不可响应或响应不过来，其实还是不可响应）。

	504 gateway time-out 顾名思义 网关超时 一般计算机中的超时就是配置错了，此处一般指nginx做反向代理服务器时，所连接的服务器tomcat无响应导致的。





14、内存泄漏与内存溢出
一、内存泄漏：
	（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果

	1）以发生的方式来分类，内存泄漏可以分为4类： 
		1. 常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。 

		2. 偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，
		偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。 

		3. 一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。
		比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。 

		4. 隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，
		因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。
		所以，我们称这类内存泄漏为隐式内存泄漏。 
	2）Java内存泄露引起原因 
		内存泄露是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成的内存空间的浪费称为内存泄露。
		内存泄露有时不严重且不易察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示你Out of memory。
	3）发生常景：
		长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，
		但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。
		
		具体主要有如下几大类： 
		1、静态集合类引起内存泄露： 
			像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，
			因为他们也将一直被Vector等引用着。

			Static Vector v = new Vector(10);
			for (int i = 1; i<100; i++)
			{
			Object o = new Object();
			v.add(o);
			o = null;
			}//

			在这个例子中，循环申请Object 对象，并将所申请的对象放入一个Vector 中，如果仅仅释放引用本身（o=null），那么Vector 仍然引用该对象，
			所以这个对象对GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从Vector 中删除，最简单的方法就是将Vector对象设置为null。
		2、单例模式

			如果单例对象持有外部对象的引用，那么这个外部对象将不能被jvm正常回收，导致内存泄露

			不正确使用单例模式是引起内存泄露的一个常见问题，单例对象在被初始化后将在JVM的整个生命周期中存在（以静态变量的方式），
			如果单例对象持有外部对象的引用，那么这个外部对象将不能被jvm正常回收，导致内存泄露

		3、各种连接 
			比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，
			否则是不会自动被GC 回收的。对于Resultset 和Statement 对象可以不进行显式回收，但Connection 一定要显式回收，
			因为Connection 在任何时候都无法自动回收，而Connection一旦回收，Resultset 和Statement 对象就会立即为NULL。
			但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset Statement 对象
			（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。
			这种情况下一般都会在try里面去的连接，在finally里面释放连接。


二、内存溢出：
	out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，
	那就是内存溢出。
	引起内存溢出的原因有很多种，常见的有以下几种： 
		1.内存中加载的数据量过于庞大，如一次从数据库取出过多数据； 
		2.集合类中有对对象的引用，使用完后未清空，使得JVM不能回收； 
		3.代码中存在死循环或循环产生过多重复的对象实体；




13、dns解析的具体过程
	DNS解析www.baidu.com
	  1）什么是ip地址
	     ip地址，指的是互联网协议地址。每一个互联网上的主机都会分配一个ip地址来作为其身份的标识
	  2）什么是域名解析
	     DNS协议通过域名查找ip地址或是逆向地从ip地址查找域名的服务
	  3）域名解析过程
		- 浏览器缓存——浏览器会按照一定的频率缓存DNS记录
		-操作系统缓存——如果浏览器缓存中没有记录，会到本地操作系统缓存中查询。（hosts文件）
		-路由缓存——路由器也有DNS缓存
		-ISP的DNS服务器：ISP（Internet Service Provider），是互联网服务提供商的简称。ISP有专门的DNS服务器对应DNS查询请求。
			根服务器：ISP的DNS服务器如果还找不到的话，ISP会代替用户想根服务器发起查询请求，进行查询。
			根域名服务器返回.com域名服务器的ip地址，然后访问.com域名服务器获取baidu.com域名服务器的ip地址，
			最后在访问baidu.com域名服务器获取www.baidu.com的ip地址，至此DNS域名解析完成。




12、僵尸进程
	概念
		僵尸进程是当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。
		如果父进程先退出 ，子进程被init接管，子进程退出后init会回收其占用的相关资源
	避免
	https://baike.baidu.com/item/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/1036577?fr=aladdin#2




11、find命令
	find [搜索范围] [匹配条件]

	选项:

	    -name 根据名字查找

	    -size    根据文件大小查找, +,-:大于设置的大小,直接写大小是等于

	    -user   查找用户名的所有者的所有文件

	    -group 根据所属组查找相关文件

	    -type    根据文件类型查找(f文件,d目录,l软链接文件)

	    -inum   根据i节点查找

	    -amin   访问时间access

	    -cmin    文件属性change

	    -mmin   文件内容modify

	*通配符来匹配下包含file的相关文件
	find / -name *file*




10、get和post的区别
	1、post请求比get请求安全，get参数直接暴露在URL上，所以不能用来传递敏感信息。post参数存放在request body中
	2、对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
	3、GET请求在URL中传送的参数是有长度限制的，而POST没有。
	4、GET请求会被浏览器主动cache，而POST不会，除非手动设置。
	5、GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。
		https://www.jianshu.com/p/5bb3cfb10318
		https://www.jianshu.com/p/75e8cb4dc48c
	7、GET产生一个TCP数据包；POST产生两个TCP数据包。

		对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；

		而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

		也就是对于一个请求，GET需要一步，而post需要两步



9、dns容易被截获的原因

	DNS劫持
		通过劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP，
		其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。DNS劫持通过篡改DNS服务器上的数据返回给用户
		一个错误的查询结果来实现的。

	DNS污染
		是一种让一般用户由于得到虚假目标主机IP而不能与其通信的方法，是一种DNS缓存投毒攻击（DNS cache poisoning）。
	
	其工作方式是：
		由于通常的DNS查询没有任何认证机制，而且DNS查询通常基于的UDP是无连接不可靠的协议，因此DNS的查询非常容易被篡改，
		通过对UDP端口53上的DNS查询进行入侵检测，一经发现与关键词相匹配的请求则立即伪装成目标域名的解析服务器（NS，Name Server）给查询者返回虚假结果。
		用户访问一个地址，国内的服务器(非DNS)监控到用户访问的已经被标记地址时，服务器伪装成DNS服务器向用户发回错误的地址的行为。





8、一个编程题，对链表使用插入排序

class Solution {
    public ListNode insertionSortList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode dummyHead = new ListNode(0);
        dummyHead.next = head;
        // head~pre是排好序的部分
        ListNode pre = head;
        // 第一个元素默认是有序的
        ListNode cur = head.next;
        while (cur != null) {
            // 寻找插入位置
            ListNode insertPre = findInsertIndexPre(dummyHead, cur);
            // 这种情况表示当前节点不需要换位置
            if (insertPre == pre) {
                pre = cur;
                cur = cur.next;
            } else {
                // cur的需要插入到insertPre后面的位置
                pre.next = cur.next;
                cur.next = insertPre.next;
                insertPre.next = cur;

                // 移动cur
                cur = pre.next;
            }
        }

        return dummyHead.next;
    }

    /**
     * 查找cur要插入位置的前一个节点
     * @param head
     * @param cur
     * @return
     */
    private ListNode findInsertIndexPre(ListNode head, ListNode cur ){
        while (head.next != cur) {
            if (head.next.val >= cur.val) {
                return head;
            }
            head = head.next;
        }
        return head;
    }
}





7、常用的排序算法及其时间复杂度
	O(N^2)
		冒泡排序
		插入排序 不稳定
		选择排序
	O(NlogN)
		归并排序 O(N)
		堆排序 O(1) (不稳定)
		快速排序 不稳定 O(logN)




6、介绍一下堆排序的过程
	1）循环遍历数组，每次添加一个数进行组合大根堆（小根堆）

	2）当所有的数都组合成为大根堆后，将首尾两数进行交换，并将尾数排出大根堆

	3）调整大根堆

	4）循环2）3）




5、用一条SQL语句查询出每门课都大于80分的学生姓名
	SELECT DISTINCT name FROM grade WHERE name NOT IN(SELECT DISTINCT name FROM grade WHERE score <=80);
	  更简单的：
	SELECT name FROM grade GROUP BY name HAVING MIN(score) > 80;
   
   查询平均分大于80的学生的姓名：
	SELECT name FROM (SELECT COUNT(*) AS t,SUM(score) AS num,name FROM `grade` GROUP BY name) AS a WHERE a.num > 80*t;
	 更简单的：
	select name, avg(score) as sc from grade g1 group by name having avg(score)>80 ;



4、从输入url到网页完全载入，都经历了哪些过程？
	一般会经历以下几个过程：
		1、域名解析(DNS解析)，解析获取相应的IP地址。
		2、浏览器向服务器发起tcp连接，与服务器建立tcp三次握手。
		3、握手成功后，浏览器向服务器发送http请求，请求数据包。
		4、服务器处理收到的请求，将数据返回至浏览器
		5、浏览器解析返回的数据并渲染页面
		6、断开连接：TCP四次挥手
		
	- 具体细节
		1、DNS解析
		  1）什么是ip地址
		     ip地址，指的是互联网协议地址。每一个互联网上的主机都会分配一个ip地址来作为其身份的标识
		  2）什么是域名解析
		     DNS协议通过域名查找ip地址或是逆向地从ip地址查找域名的服务
		  3）域名解析过程
			- 浏览器缓存——浏览器会按照一定的频率缓存DNS记录
			-操作系统缓存——如果浏览器缓存中没有记录，会到本地操作系统缓存中查询。（hosts文件）
			-路由缓存——路由器也有DNS缓存
			-ISP的DNS服务器：ISP（Internet Service Provider），是互联网服务提供商的简称。ISP有专门的DNS服务器对应DNS查询请求。
				根服务器：ISP的DNS服务器如果还找不到的话，ISP会代替用户向根服务器发起查询请求，进行查询。
				根域名服务器返回.com域名服务器的ip地址，然后访问.com域名服务器获取baidu.com域名服务器的ip地址，
				最后在访问baidu.com域名服务器获取www.baidu.com的ip地址，至此DNS域名解析完成。
		2、tcp三次握手
		  1）网络七层模型
		       ——应用层（ftp，http，smtp，pop3）
		       ——表示层
		       ——会话层

		       ——传输层（TCP）
		       ——网络层（IP）
		       ——数据链路层
		       ——物理层
		  2）TCP三次握手
			——客户端发送有待带有SYN=1，Seq=x的syn包到服务器，并进入到SYN_SEND状态，等待服务器确认。
			——服务器收到syn包后，必须确认客户的SYN（ack=x+1），同时发送一个自己的SYN（seq=k）包给客户端（即SYN+ACK包），同时服务器进入到SYN_RECV状态。
			——客户端收到服务器的SYN+ACK包后，向服务器发一个确认包ACK（k+1），这些包发送完毕后，客户端和服务器同时进入到ESTABLISHED状态，完成三次握手。
		  3）为什么需要三次握手？
			——《计算机网络》中讲“三次握手”的目的是“为了防止已经失效的连接请求报文突然又传送到了服务端，因而产生了错误”。
			——主要是为了防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。
				如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送的第一个请求连接并且没有丢失，只是因为在网络中滞留的时间太长了，
				由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，
				传输数据，然后关闭连接。此时之前滞留的那一次请求连接，因为网络通畅了, 到达了服务器，这个报文本该是失效的，但是，
				两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的费。如果采用的是三次握手，就算是那一次失效的报文传送过来了，
				服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。
		3、发送http请求
		  1）http请求
			——在TCP三次握手结束后，客户端就可以向服务端发送http请求报文了。
			  请求报文包含三部分：请求行，请求头，请求主体。
			——请求行包含请求方法，URL，协议版本
			例：POST /chapter17/user.html HTTP/1.1
			8中请求方法：get，post，put，delete，patch，head，options，trace
			——请求头包含了请求的附加信息，一般以key:value的形式存在。比如关于客户端的信息，host（主机名）。
			请求体包含了多个请求参数的数据，包含了回车符、换行符、请求数据，并不是所有的请求都带有请求数据。
			例：name=tom&age=23 （这里承载着name，age三个请求参数）

			服务器收到请求后处理请求，并返回响应报文数据。
			响应报文包含三部分：响应行，响应头，响应主题。
			——响应行包含了协议版本，状态码，状态码描述
			——响应头包含了一些附加的响应信息
			——相应主体包含回车符、换行符和响应返回的数据，并不是所有的响应都有响应数据
		4、服务器处理收到的请求，将数据返回至浏览器
			浏览器根据URL（这里是URL）内容生成HTTP请求，请求中包含请求文件的位置，请求文件的方式等。
			
			服务器接到请求后，会根据HTTP请求中的内容来决定如何获取相应的HTML文件。
			
			服务器将得到的HTML文件发送给浏览器。
			
			在浏览器还没有完全接收HTML文件时便开始渲染，显示网页。
			在执行HTML中代码时，根据需要，浏览器会继续请求图片，css，js等文件。
		5、渲染过程
			HTML代码转化为DOM（DOM Tree）
			
			CSS代码转化成CSSOM（CSS Object Model）
			结合DOM和CSSOM，生成一棵渲染树（包含每个节点的视觉信息）（Render Tree）
			生成布局（layout），将所有渲染树的所有节点进行平面合成
			
			将布局绘制（paint）在屏幕上
			使用JavaScript脚本来动态的修改DOM,以便给Web应用带来动态行为
			Web应用的执行分为两个阶段


			全局JavaScript代码遇到script节点时执行。在这个执行过程中，其能够以任意程度改变当前的DOM(有可能触发页面的重绘和回流)
			关于事件处理，在同一时刻，只能处理多个不同事件中的一个，处理顺序是事件的生成循序(队列顺序)，事件处理阶段大量依赖事件队列，
			事件循环会检查事件队列的头部，如果检测到了一个事件，相应的事件处理器就会被调用(
		6、四次挥手
			数据传输完毕后，双方都可以释放连接.
			此时客户端和服务器都是处于ESTABLISHED状态，然后客户端主动断开连接，服务器被动断开连接.
			1, 客户端进程发出连接释放报文，并且停止发送数据。
				释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时客户端进入FIN-WAIT-1（终止等待1）状态。
				TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
			
			2, 服务器收到连接释放报文，发出确认报文，ACK=1，确认序号为 u+1，并且带上自己的序列号seq=v，此时服务端就进入了CLOSE-WAIT（关闭等待）状态。
				TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，
				但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
			
			3, 客户端收到服务器的确认请求后，此时客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文
				（在这之前还需要接受服务器发送的最终数据）
			
			4, 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，确认序号为v+1，由于在半关闭状态，服务器很可能又发送了一些数据，
			假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
			
			5, 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，确认序号为w+1，而自己的序列号是u+1，
				此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，
				当客户端撤销相应的TCB后，才进入CLOSED状态。
			
			6, 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，
				服务器结束TCP连接的时间要比客户端早一些。
		7、补充说明：HTTPS与HTTP的区别
			1）HTTPS的工作原理

				浏览器将自己支持的一套加密规则发送给网站;
				网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，
				以及证书的颁发机构等信息。

				浏览器获得网站证书之后验证证书的合法性(如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，
				并用证书中提供的公钥加密)

				使用约定好的HASH算法计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站

			2）HTTPS和HTTP协议的区别

				https协议需要到ca申请证书，一般免费证书很少，需要交费。

				http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。

				http和https使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443。

				http的连接很简单,是无状态的 。无状态的意思就是给他一样的参数你要有一样的结果,通过增加cookie和session机制，
				现在的网络请求其实是有状态的。

				HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议， 要比http协议安全。
		8、举个栗子
			当我们在浏览器中输入www.baidu.com时，直到我们呈现出页面，会发生以下事情（Chrome浏览器）

			首先 Chrome 搜索自身的 DNS 缓存。(如果 DNS 缓存中找到百度的 IP 地址，就跳过了接下来查找 IP 地址步骤，直接访问该 IP 地址。)
			
			搜索操作系统自身的 DNS 缓存。(浏览器没有找到缓存或者缓存已经失效)
			
			读取硬盘中的 host 文件，里面记录着域名到 IP 地址的映射关系，Mac 电脑中位于 /etc/hosts。(如果前1.2步骤都没有找到)
			
			浏览器向宽带运营商服务器或者域名服务器发起一个 DNS 解析请求，这里服务器有两种方式解析请求，这在稍后会讲到，
			之后浏览器获得了百度首页的 IP 地址。
			
			拿到 IP 地址后，浏览器就向该 IP 所在的服务器建立 TCP 连接(即三次握手)。
			
			连接建立起来之后，浏览器就可以向服务器发起 HTTP 请求了。(这里比如访问百度首页，就向服务器发起 HTTP 中的 GET 请求)
			
			服务器接受到这个请求后，根据路径参数，经过后台一些处理之后，把处理后的结果返回给浏览器，如果是百度首页，
			就可以把完整的 HTML 页面代码返回给浏览器。
			
			浏览器拿到了百度首页的完整 HTML 页面代码，内核和 JS 引擎就会解析和渲染这个页面，里面的 JS，CSS，
			图片等静态资源也通过一个个 HTTP 请求进行加载。
			
			浏览器根据拿到的资源对页面进行渲染，最终把完整的页面呈现给用户。如果浏览器没有后续的请求，那么就会跟服务器端发起 TCP 断开(即四次挥手)。






3、简述堆和栈的区别
	1.内存中的堆栈
	内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区。
	代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。
	静态数据区：存储全局变量、静态变量、常量，常量包括final修饰的常量和String常量。系统自动分配和回收。
	栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。
	例如 int method(int a){int b;}栈中存储参数a、局部变量b、返回值temp。
	堆区：new一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。由程序员分配和回收（Java中由JVM虚拟机的垃圾回收机制自动回收）。
	例如 Class Student{int num; int age;} main方法中Student stu = new Student()；分配堆区空间中存储的该对象的num、age，变量stu存储在栈中，
	里面的值是对应堆区空间的引用或地址。
	
	2.数据结构中的堆栈
	栈：是一种连续存储的数据结构，特点是存储的数据先进后出。
	堆：是一棵完全二叉树结构，特点是父节点的值大于（小于）两个子节点的值（分别称为大根堆和小根堆）。
	它常用于管理算法执行过程中的信息，应用场景包括堆排序，优先队列等。


2、Java多态
	一、什么是多态

		1.面向对象的三大特性：封装、继承、多态。

		2.多态的定义：指允许不同类的对象对同一消息做出不同的响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）

		3.实现多态的技术称为：动态绑定（dynamic binding），是指在运行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。

		4.多态的作用：消除类型之间的耦合关系。


	二、多态存在的三个必要条件

		1、要有继承；

		2、要有重写；

		3、父类引用指向子类对象。

	三、Java中多态的实现方式：
		接口实现，继承父类进行方法重写，同一个类中进行方法重载。

	四、多态的体现

		父类的引用指向了自己的子类对象

		父类的引用也可以接收自己的对象

	五、多态的好处

		多态的出现大大的提高了程序的扩展性

	六、多态的弊端

		只能使用父类的引用访问父类的成员



1、a==b与a.equals(b)的区别
	a==b:当a和b指向同一对象时为true，即a和b指向内存和内存地址的内容都相同时才为true；（地址相同，内容必相同）

	a.equals(b):当a和b的值相同时，即为ture；（只判断值相等）
