"""
995. K 连续位的最小翻转次数

在仅包含 0 和 1 的数组 A 中，一次 K 位翻转包括选择一个长度为 K 的（连续）子数组，同时将子数组中的每个 0 更改为 1，而每个 1 更改为 0。

返回所需的 K 位翻转的次数，以便数组没有值为 0 的元素。如果不可能，返回 -1。

示例 1：

输入：A = [0,1,0], K = 1
输出：2
解释：先翻转 A[0]，然后翻转 A[2]。
示例 2：

输入：A = [1,1,0], K = 2
输出：-1
解释：无论我们怎样翻转大小为 2 的子数组，我们都不能使数组变为 [1,1,1]。
示例 3：

输入：A = [0,0,0,1,0,1,1,0], K = 3
输出：3
解释：
翻转 A[0],A[1],A[2]: A变成 [1,1,1,1,0,1,1,0]
翻转 A[4],A[5],A[6]: A变成 [1,1,1,1,1,0,0,0]
翻转 A[5],A[6],A[7]: A变成 [1,1,1,1,1,1,1,1]


提示：

1 <= A.length <= 30000
1 <= K <= A.length



贪心 + 事件
思路

如果最左边的元素是 0，那么我们一定要翻转从位置 0 开始的子数组。
类似的，如果最左边的元素是 1，我们不应该翻转从位置 0 开始的子数组。
这证明了我们可以贪心地执行这一过程：
    在明确是否要反转第一个子数组之后（位置 0 至 K-1），
    我们可以考虑将数组中第一个元素（值为 1）移除，然后重复这个过程。

我们还可以做得更好。每次翻转一个子数组 A[i], A[i+1], ..., A[i+K-1]，
我们可以考虑这样的两种事件：
    第一种是 “开始事件”，标记位置 i 为我们翻转子数组的开始，
    另一种是 “结束事件” ，标记位置 i+K 是我们翻转子数组的结束。
使用这些事件，我们就可以知道某一个位置被多少个重叠的翻转子数组覆盖了：它的数值等于 “开始事件” 的数量减去 “结束事件” 的数量。

算法

当我们翻转一个子数组的时候，让我们称翻转子数组的下标集合为一个区间。
我们将维护一个变量 flip，也就是覆盖当前位置的重叠区间数量。我们只关心 flip 对 2 取模之后的值。

当我们翻转从 i 开始的一个区间，我们在位置 i+K 创建一个 “结束事件” 的提示，表明在那里要把翻转状态置反。
"""


class MinKBitFlips:
    def minKBitFlips(self, A, K):
        N = len(A)  # 列表长度
        hint = [0] * N  # 创建一个列表用来记录元素是否需要进行翻转
        flip = 0  # 翻转事件标志

        res = 0  # 翻转次数
        # 当我们翻转子数组形如 A[i], A[i+1], ..., A[i+K-1]
        # 我们可以在此位置置反翻转状态，并且在位置 i+K 设置一个提醒，告诉我们在那里也要置反翻转状态
        for i, x in enumerate(A):
            flip ^= hint[i]
            if x ^ flip == 0:
                res += 1
                if i + k > N:
                    return -1
                flip ^= 1
                if i + k < N:
                    hint[i + k] ^= 1
        print(hint)
        return res


if __name__ == '__main__':
    mink = MinKBitFlips()
    A = [0, 0, 0, 1, 0, 1, 1, 0]
    k = 3
    print(mink.minKBitFlips(A, k))
