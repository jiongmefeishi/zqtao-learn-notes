**年轻即出发**...

**简书**：https://www.jianshu.com/u/7110a2ba6f9e

**知乎**：https://www.zhihu.com/people/zqtao23/posts

**GitHub源码**：https://github.com/zqtao2332

**个人网站**：http://www.zqtaotao.cn/  （停止维护更新内容）

**QQ交流群**：606939954

​	    咆哮怪兽一枚...嗷嗷嗷...趁你现在还有时间，尽你自己最大的努力。努力做成你最想做的那件事，成为你最想成为的那种人，过着你最想过的那种生活。也许我们始终都只是一个小人物，但这并不妨碍我们选择用什么样的方式活下去，这个世界永远比你想的要更精彩。



最后：喜欢编程，对生活充满激情

------

------

```java
/**
 * @description: 两人选数游戏
 * 思路1、递归: 暴力尝试
 * @version: 1.0
 */
public class Code_01_CardsInLine_1 {

    // 方式1、递归: 暴力尝试
    public static int win1(int[] arr) {
        if (arr == null || arr.length == 0) return 0;

        // 自己分别作为先选人，后选人，查看收益最大
        // 无论是作为先选人，还是作为后选人，都是绝对理智的，每一次做出的选择都是最优的
        return Math.max(first(arr, 0, arr.length - 1), second(arr, 0, arr.length - 1));
    }

    /*
        作为先选人，从 i 到 j 位置上获得的最大分数

        核心：我作为先选人每一次决策都是选择的最优的

        如：
        5 2 3 4
        那么我作为先选者一定最终做出的选择的是 （5 + 作为后选人最大分数）（4 + 作为后选人最大分数）中最大分数的
     */
    public static int first(int[] arr, int i, int j) {
        if (i == j) { // 只有一个数，同时作为先选人，当然返回这个唯一的数
            return arr[i];
        }

        // 选择左边数，然后自己变成了后选人
        // 从 i 到 j 位置上获得的最大分数 = 左边数 + 自己变为后选人从 i+1 到 j 位置上获得的最大分数
        int L = arr[i] + second(arr, i + 1, j);

        // 选择右边数，然后自己变成了后选人
        // 从 i 到 j 位置上获得的最大分数 = 右边数 + 自己变为后选人从 i 到 j-1 位置上获得的最大分数
        int R = arr[j] + second(arr, i, j - 1);

        // 返回自己选择左边数和选择右边数两种情况下，最大的分数
        return Math.max(L, R);
    }

    /*
        作为后选人，从i 到 j 位置上获得的最大分数

        核心：每一次都认为先选人做出的选择是最优的，留给自己的一定是最小的

        5 2 3 4
        先选人，选了 5 给自己留下 2 3 4 = 9
        先选人，选了 4 给自己留下 5 2 3 = 10

        先选人怎么可能那么好心让自己赢，我们都是绝对理智的人
        所以

        我作为后选人，悲催的只能在先选人选择后的区域选择我的数
        但是我现在也不知道那边的数大，需要计算才能知道先选人选择的到底是哪边的数？

        5 2 3 4
        先选人，选了 5 给自己留下 2 3 4 = 9
        先选人，选了 4 给自己留下 5 2 3 = 10

        通过计算发现，9 < 10 ，先选人既然是绝对理智的，那么他给我留下的就是最小的
        而我，只能从最小的那几个数中找最大的分数。

        由于先选人已经选择了，现在他退位到后选人，我上了先选人位置，即，我现在是先选人。

        总结: 我作为后选人做出什么样的决定，完全取决于先选人做出了什么决定，先选人扔给我的一定是最小的

     */
    public static int second(int[] arr, int i, int j) {
        if (i == j) { //只有一个数，自己作为后选人，自己前面有一个先选人，先选人选择后，剩下0个数可选
            return 0;
        }

        // 现在我是先选人，选择左边数
        int L = first(arr, i + 1, j);
        // 现在我是先选人，选择右边数
        int R = second(arr, i, j - 1);

        // 我只能从最小的区域中进行选择
        return Math.min(L, R);
    }
}

```