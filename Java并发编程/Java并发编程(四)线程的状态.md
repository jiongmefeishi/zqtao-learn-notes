# **Java并发编程(四)-线程的状态**

## 线程的状态



### 初始态：NEW

创建一个Thread对象，但还未调用start()启动线程时，线程处于初始态。



### 运行态：RUNNABLE

在Java中，运行态包括就绪态 和 运行态。



- 就绪态 
  该状态下的线程已经获得执行所需的所有资源，只要CPU分配执行权就能运行。
  所有就绪态的线程存放在就绪队列中。
- 运行态 
  获得CPU执行权，正在执行的线程。
  由于一个CPU同一时刻只能执行一条线程，因此每个CPU每个时刻只有一条运行态的线程。



### 阻塞态

- 当一条正在执行的线程请求某一资源失败时，就会进入阻塞态。
- 而在Java中，阻塞态专指请求锁失败时进入的状态。
- 由一个阻塞队列存放所有阻塞态的线程。
- 处于阻塞态的线程会不断请求资源，一旦请求成功，就会进入就绪队列，等待执行。


PS：锁、IO、Socket等都资源。



### 等待态

- 当前线程中调用wait、join、park函数时，当前线程就会进入等待态。
- 也有一个等待队列存放所有等待态的线程。
- 线程处于等待态表示它需要等待其他线程的指示才能继续运行。
- 进入等待态的线程会释放CPU执行权，并释放资源（如：锁）



### 超时等待态

- 当运行中的线程调用sleep(time)、wait、join、parkNanos、parkUntil时，就会进入该状态；
- 它和等待态一样，并不是因为请求不到资源，而是主动进入，并且进入后需要其他线程唤醒；
- 进入该状态后释放CPU执行权 和 占有的资源。
- 与等待态的区别：到了超时时间后自动进入阻塞队列，开始竞争锁。



### 终止态

线程执行结束后的状态。



## 线程状态转换图

![](https://leanote.com/api/file/getImage?fileId=58737829ab6441209e01b006)



**初始态——>就绪态**

当线程对象调用start()方法时就会进入就绪态，若就绪队列没有线程，则直接进入运行态。



**就绪态——>运行态**

由系统调用完成。



**就绪态<——运行态**


调用Thread.yield()函数
由系统调用完成（当线程时间片用完）



**运行态——>阻塞态**

当线程请求锁失败时进入阻塞态。



**阻塞态——>就绪态**

阻塞队列中的线程会不断检查锁是否可用，一旦可用就进入就绪队列。



**运行态——>等待态**

1. 调用Object.wait()方法 
   1. wait方法必须在同步块内部；
   2. 必须由同步块的锁对象调用；
   3. 必须由notify方法和wait方法必须由同一个锁对象调用
2. 调用Thread.join()方法
3. 调用LockSupport.park()方法



**等待态——>就绪态**

某一个线程调用了 锁对象.notify()方法，并且等待的线程并不需要锁



**等待态——>阻塞态**

锁对象.notify()方法，并且等待的线程需要锁同步。



## 注意点

1. wait()方法会释放CPU执行权 和 占有的锁。
2. sleep(long)方法仅释放CPU使用权，锁仍然占用；线程被放入超时等待队列，与yield相比，它会使线程较长时间得不到运行。
3. yield()方法仅释放CPU执行权，锁仍然占用，线程会被放入就绪队列，会在短时间内再次执行。
4. wait和notify必须配套使用，即必须使用同一把锁调用；
5. wait和notify必须放在一个同步块中
6. 调用wait和notify的对象必须是他们所处同步块的锁对象。

